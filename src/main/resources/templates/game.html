<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Car Battle Game</title>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .game-area {
            border: 3px solid #333;
            background: #e8f4f8;
            margin: 20px 0;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: background 0.3s;
        }
        button:hover {
            background: #45a049;
        }
        button.stop {
            background: #f44336;
        }
        button.stop:hover {
            background: #da190b;
        }
        .status {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #007bff;
        }
        .ai-selector {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }
        select {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 th:text="${message}">Car Battle Game</h1>

    <div class="controls">
        <button onclick="startGame()">üéÆ Start Game</button>
        <button class="stop" onclick="stopGame()">‚èπÔ∏è Stop Game</button>
        <button onclick="openAIEditor()">ü§ñ AI Editor</button>
    </div>

    <div class="ai-selector">
        <div>
            <label>Player 1 (Blue):</label>
            <select id="player1AI">
                <option value="simple">Simple AI</option>
                <option value="aggressive">Aggressive AI</option>
                <option value="defensive">Defensive AI</option>
            </select>
        </div>
        <div>
            <label>Player 2 (Red):</label>
            <select id="player2AI">
                <option value="simple">Simple AI</option>
                <option value="aggressive">Aggressive AI</option>
                <option value="defensive">Defensive AI</option>
            </select>
        </div>
    </div>

    <div class="status" id="gameStatus">
        <strong>Status:</strong> <span id="statusText">Ready to start</span>
    </div>

    <canvas id="gameArea" class="game-area" width="800" height="600">
        Your browser does not support the canvas element.
    </canvas>

    <div id="debugInfo" style="margin-top: 20px; padding: 10px; background: #fff3cd; border-radius: 5px;"></div>
</div>

<script>
    let gameRunning = false;
    let animationId = null;
    const canvas = document.getElementById('gameArea');
    const ctx = canvas.getContext('2d');

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã —Å —Å–µ—Ä–≤–µ—Ä–∞
    let gameState = {
        player1: { x: 100, y: 100, angle: 0, health: 100, alive: true, name: "Player 1" },
        player2: { x: 700, y: 500, angle: 180, health: 100, alive: true, name: "Player 2" },
        gameRunning: false
    };

    function updateStatus(message) {
        document.getElementById('statusText').textContent = message;
        console.log('Status:', message);
    }

    function debug(message) {
        const debugDiv = document.getElementById('debugInfo');
        debugDiv.innerHTML = '<strong>Debug:</strong> ' + message;
        console.log('Debug:', message);
    }

    async function startGame() {
        if (gameRunning) {
            updateStatus('Game is already running');
            return;
        }

        try {
            updateStatus('Starting game...');

            // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ AI
            const player1AI = document.getElementById('player1AI').value;
            const player2AI = document.getElementById('player2AI').value;

            const startData = {
                player1AI: player1AI,
                player2AI: player2AI
            };

            const response = await fetch('/game/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(startData)
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            debug('Start response: ' + JSON.stringify(data));

            gameState = data;
            gameRunning = true;
            updateStatus('Game running');

            gameLoop();

        } catch (error) {
            updateStatus('Error starting game: ' + error.message);
            debug('Error: ' + error.message);
            console.error('Error starting game:', error);
        }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö AI –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
    async function loadCustomAIs() {
        try {
            const response = await fetch('/ai/list');
            const data = await response.json();

            updateAISelectors(data.customAIs);
        } catch (error) {
            console.error('Error loading custom AIs:', error);
        }
    }

    function updateAISelectors(customAIs) {
        const selectors = ['player1AI', 'player2AI'];

        selectors.forEach(selectorId => {
            const selector = document.getElementById(selectorId);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –æ–ø—Ü–∏–∏
            const standardOptions = Array.from(selector.options)
                .filter(opt => !opt.value.startsWith('custom_'));

            // –û—á–∏—â–∞–µ–º –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –æ–ø—Ü–∏–∏
            selector.innerHTML = '';
            standardOptions.forEach(opt => selector.add(opt));

            // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ AI
            if (customAIs) {
                Object.keys(customAIs).forEach(aiKey => {
                    const option = document.createElement('option');
                    option.value = `custom_${aiKey}`;
                    option.textContent = customAIs[aiKey] + ' (Custom)';
                    selector.add(option);
                });
            }
        });
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ AI –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    window.addEventListener('load', function() {
        loadCustomAIs();
        // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    });

    function stopGame() {
        gameRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
        }

        fetch('/game/stop', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                updateStatus('Game stopped');
                debug('Game stopped by user');
            });
    }

    async function gameLoop() {
        if (!gameRunning) return;

        await updateGame();
        renderGame();

        animationId = requestAnimationFrame(gameLoop);
    }

    async function updateGame() {
        if (!gameRunning) return;

        try {
            const response = await fetch('/game/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.ok) {
                const newState = await response.json();
                gameState = newState;
                debug(`P1:(${gameState.player1.x.toFixed(1)},${gameState.player1.y.toFixed(1)}) ` +
                    `P2:(${gameState.player2.x.toFixed(1)},${gameState.player2.y.toFixed(1)})`);
            }
        } catch (error) {
            console.error('Error updating game:', error);
        }
    }

    function renderGame() {
        // –û—á–∏—Å—Ç–∫–∞ canvas
        ctx.fillStyle = '#e8f4f8';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–µ—Ç–∫–∏
        ctx.strokeStyle = '#d1e7f0';
        ctx.lineWidth = 1;
        for (let x = 0; x <= canvas.width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—É–ª—å
        if (gameState.bullets) {
            gameState.bullets.forEach(bullet => {
                drawBullet(bullet.x, bullet.y, bullet.angle);
            });
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏—é –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        const collision = checkCollision(gameState.player1, gameState.player2);

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–∞—à–∏–Ω–æ–∫ –∏–∑ gameState
        if (gameState.player1 && gameState.player1.alive) {
            const color = collision ? 'purple' : 'blue';
            drawCar(gameState.player1.x, gameState.player1.y, gameState.player1.angle, color, gameState.player1.name);
        }

        if (gameState.player2 && gameState.player2.alive) {
            const color = collision ? 'orange' : 'red';
            drawCar(gameState.player2.x, gameState.player2.y, gameState.player2.angle, color, gameState.player2.name);
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ HUD
        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        const canShoot1 = gameState.player1.canShoot ? 'READY' : 'RELOAD';
        const canShoot2 = gameState.player2.canShoot ? 'READY' : 'RELOAD';

        ctx.fillText(`Player 1 (Blue) - ${gameState.player1.health}HP [${canShoot1}]`, 10, 20);
        ctx.fillText(`Player 2 (Red) - ${gameState.player2.health}HP [${canShoot2}]`, 550, 20);

        // –°—Ç–∞—Ç—É—Å –∏–≥—Ä—ã –∏ –∫–æ–ª–ª–∏–∑–∏–∏
        ctx.fillText(`Game: ${gameRunning ? 'RUNNING' : 'STOPPED'} | Bullets: ${gameState.bullets ? gameState.bullets.length : 0}`, 300, 20);

        if (collision) {
            ctx.fillStyle = 'red';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('COLLISION!', canvas.width / 2, 45);
            ctx.textAlign = 'left';
        }
    }

    function drawBullet(x, y, angle) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);

        // –ü—É–ª—è - –º–∞–ª–µ–Ω—å–∫–∏–π –∂–µ–ª—Ç—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
        ctx.fillStyle = 'yellow';
        ctx.fillRect(0, -2, 8, 4);

        // –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä–∞—Å—Å–µ—Ä–∞
        ctx.strokeStyle = 'orange';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.lineTo(0, 0);
        ctx.stroke();

        ctx.restore();
    }

    function drawCar(x, y, angle, color, name) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);

        // –ö—É–∑–æ–≤ –º–∞—à–∏–Ω—ã
        ctx.fillStyle = color;
        ctx.fillRect(-15, -10, 30, 20);

        // –í–µ—Ç—Ä–æ–≤–æ–µ —Å—Ç–µ–∫–ª–æ
        ctx.fillStyle = '#aaccff';
        ctx.fillRect(-10, -8, 20, 8);

        // –î—É–ª–æ —Ç–∞–Ω–∫–∞
        ctx.fillStyle = '#333';
        ctx.fillRect(10, -2, 15, 4);

        ctx.restore();

        // –ó–æ–Ω–∞ –∫–æ–ª–ª–∏–∑–∏–∏
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);

        // –ò–º—è –∏ –∑–¥–æ—Ä–æ–≤—å–µ –ø–æ–¥ –º–∞—à–∏–Ω–æ–π
        ctx.fillStyle = 'black';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${name} (${Math.round(x)},${Math.round(y)})`, x, y + 40);
        ctx.textAlign = 'left';
    }

    function checkCollision(player1, player2) {
        if (!player1 || !player2) return false;

        const dx = player1.x - player2.x;
        const dy = player1.y - player2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        return distance < 40;
    }

    function drawCar(x, y, angle, color, name) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);

        // –ö—É–∑–æ–≤ –º–∞—à–∏–Ω—ã
        ctx.fillStyle = color;
        ctx.fillRect(-15, -10, 30, 20);

        // –í–µ—Ç—Ä–æ–≤–æ–µ —Å—Ç–µ–∫–ª–æ
        ctx.fillStyle = '#aaccff';
        ctx.fillRect(-10, -8, 20, 8);

        // –î—É–ª–æ —Ç–∞–Ω–∫–∞
        ctx.fillStyle = '#333';
        ctx.fillRect(10, -2, 15, 4);

        ctx.restore();

        // –ó–æ–Ω–∞ –∫–æ–ª–ª–∏–∑–∏–∏ (–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –∫—Ä—É–≥)
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);

        // –ò–º—è –∏ –∑–¥–æ—Ä–æ–≤—å–µ –ø–æ–¥ –º–∞—à–∏–Ω–æ–π
        ctx.fillStyle = 'black';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${name} (${Math.round(x)},${Math.round(y)})`, x, y + 40);
        ctx.textAlign = 'left';
    }

    function openAIEditor() {
        window.open('/ai/editor', '_blank');
    }

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    window.addEventListener('load', async function() {
        updateStatus('Loading game state...');

        try {
            const response = await fetch('/game/state');
            const state = await response.json();
            gameState = state;
            updateStatus('Ready to start');
            renderGame(); // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        } catch (error) {
            updateStatus('Error loading game state');
            debug('Error: ' + error.message);
        }
    });
</script>
</body>
</html>